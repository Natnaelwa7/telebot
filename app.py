import os
import logging
import json
import psycopg2
import re
from datetime import datetime, timedelta
import pytz
from telegram import Update, ReplyKeyboardMarkup, ReplyKeyboardRemove, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, ContextTypes, ConversationHandler, filters, CallbackQueryHandler
import math
import validators
from time import sleep
from shapely.geometry import Point, Polygon

# Enable logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO
)
logger = logging.getLogger(__name__)

# Your credentials
BOT_TOKEN = "7386306627:AAHdCm0OMiitG09dEbD0qmjbNT-pvq0Ny6A"
DATABASE_URL = "postgresql://postgres.unceacyznxuawksbfctj:Aster#123#@aws-1-eu-north-1.pooler.supabase.com:6543/postgres"
ADMIN_IDS = [8188464845]

# Admin locations (hardcoded) - treated as polygon vertices (lat, lon)
ADMIN_LOCATIONS = [
    (9.020238599143552, 38.82560078203035),
    (9.017190196514154, 38.75281767667821),
    (8.98208254568819, 38.75948863161473),
    (8.980054995596422, 38.77906699321482),
    (8.985448934391043, 38.79958228020363),
    (9.006143350714895, 38.78995524036579)
]

# Create the delivery polygon (shapely expects (lon, lat))
DELIVERY_POLYGON = Polygon([(lon, lat) for lat, lon in ADMIN_LOCATIONS])

# Time zone for East Africa Time (EAT, UTC+3)
EAT = pytz.timezone('Africa/Nairobi')

# Conversation states
(
    MAIN_MENU, REGISTER_NAME, REGISTER_PHONE, REGISTER_LOCATION, CONFIRM_REGISTRATION,
    ADMIN_UPDATE_MENU, ADMIN_ANNOUNCE, ADMIN_DAILY_ORDERS,
    ADMIN_DELETE_MENU, SET_ADMIN_LOCATION, ADMIN_APPROVE_PAYMENT, SUPPORT_MENU
) = range(12)

# Database connection helper
def get_db_connection():
    try:
        conn = psycopg2.connect(DATABASE_URL, sslmode='require')
        conn.set_session(autocommit=False)
        return conn
    except Exception as e:
        logger.error(f"Failed to connect to database: {e}")
        raise

# Initialize database
def init_db():
    conn = None
    cur = None
    try:
        conn = get_db_connection()
        cur = conn.cursor()
        # Create schema if not exists
        cur.execute("CREATE SCHEMA IF NOT EXISTS public")
        # Create users table
        cur.execute('''
            CREATE TABLE IF NOT EXISTS public.users (
                id SERIAL PRIMARY KEY,
                telegram_id BIGINT UNIQUE NOT NULL,
                username VARCHAR(255),
                full_name VARCHAR(255),
                phone_number VARCHAR(20),
                location VARCHAR(255),
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        cur.execute("ALTER TABLE public.users DISABLE ROW LEVEL SECURITY")
        # Create subscriptions table
        cur.execute('''
            CREATE TABLE IF NOT EXISTS public.subscriptions (
                id SERIAL PRIMARY KEY,
                user_id BIGINT,
                plan_type VARCHAR(50) NOT NULL,
                meals_remaining INTEGER NOT NULL,
                selected_dates JSONB NOT NULL,
                expiry_date TIMESTAMP NOT NULL,
                status VARCHAR(50) DEFAULT 'pending',
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES public.users(telegram_id) ON DELETE CASCADE
            )
        ''')
        cur.execute("ALTER TABLE public.subscriptions DISABLE ROW LEVEL SECURITY")
        # Add selected_dates column if it doesn't exist
        cur.execute("""
            DO $$
            BEGIN
                IF NOT EXISTS (
                    SELECT 1
                    FROM information_schema.columns
                    WHERE table_schema = 'public'
                    AND table_name = 'subscriptions'
                    AND column_name = 'selected_dates'
                ) THEN
                    ALTER TABLE public.subscriptions ADD COLUMN selected_dates JSONB NOT NULL DEFAULT '[]';
                END IF;
            END$$;
        """)
        # Create categories table
        cur.execute('''
            CREATE TABLE IF NOT EXISTS public.categories (
                id SERIAL PRIMARY KEY,
                name VARCHAR(255) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        cur.execute("ALTER TABLE public.categories DISABLE ROW LEVEL SECURITY")
        # Create menu_items table
        cur.execute('''
            CREATE TABLE IF NOT EXISTS public.menu_items (
                id SERIAL PRIMARY KEY,
                name VARCHAR(255) NOT NULL,
                description TEXT,
                price DECIMAL(10,2) NOT NULL,
                category_id INTEGER,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (category_id) REFERENCES public.categories(id)
            )
        ''')
        cur.execute("ALTER TABLE public.menu_items DISABLE ROW LEVEL SECURITY")
        # Create weekly_menus table
        cur.execute('''
            CREATE TABLE IF NOT EXISTS public.weekly_menus (
                id SERIAL PRIMARY KEY,
                week_start_date DATE NOT NULL,
                menu_items JSONB NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        cur.execute("ALTER TABLE public.weekly_menus DISABLE ROW LEVEL SECURITY")
        # Add unique constraint
        cur.execute("""
            DO $$
            BEGIN
                IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'unique_week_start_date') THEN
                    ALTER TABLE public.weekly_menus ADD CONSTRAINT unique_week_start_date UNIQUE (week_start_date);
                END IF;
            END$$;
        """)
        # Create orders table
        cur.execute('''
            CREATE TABLE IF NOT EXISTS public.orders (
                id SERIAL PRIMARY KEY,
                user_id BIGINT,
                subscription_id INTEGER,
                meal_date DATE NOT NULL,
                items JSONB NOT NULL,
                status VARCHAR(50) DEFAULT 'confirmed',
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES public.users(telegram_id) ON DELETE SET NULL,
                FOREIGN KEY (subscription_id) REFERENCES public.subscriptions(id) ON DELETE SET NULL
            )
        ''')
        cur.execute("ALTER TABLE public.orders DISABLE ROW LEVEL SECURITY")
        # Create payments table
        cur.execute('''
            CREATE TABLE IF NOT EXISTS public.payments (
                id SERIAL PRIMARY KEY,
                user_id BIGINT,
                subscription_id INTEGER,
                amount DECIMAL(10,2) NOT NULL,
                receipt_url TEXT,
                status VARCHAR(50) DEFAULT 'pending',
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES public.users(telegram_id) ON DELETE SET NULL,
                FOREIGN KEY (subscription_id) REFERENCES public.subscriptions(id) ON DELETE SET NULL
            )
        ''')
        cur.execute("ALTER TABLE public.payments DISABLE ROW LEVEL SECURITY")
        # Create settings table
        cur.execute('''
            CREATE TABLE IF NOT EXISTS public.settings (
                key VARCHAR(255) PRIMARY KEY,
                value TEXT NOT NULL,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        cur.execute("ALTER TABLE public.settings DISABLE ROW LEVEL SECURITY")
        # Insert default categories if none exist
        cur.execute("SELECT COUNT(*) FROM public.categories")
        if cur.fetchone()[0] == 0:
            cur.execute("INSERT INTO public.categories (name) VALUES ('Main Dishes'), ('Sides'), ('Drinks'), ('Desserts')")
        conn.commit()
        logger.info("Database initialized successfully")
    except Exception as e:
        logger.error(f"Error initializing database: {e}")
        if conn:
            conn.rollback()
    finally:
        if cur:
            cur.close()
        if conn:
            conn.close()

# Helper function to ensure user exists
async def ensure_user_exists(user, conn, cur):
    try:
        cur.execute(
            "INSERT INTO public.users (telegram_id, username, full_name) "
            "VALUES (%s, %s, %s) ON CONFLICT (telegram_id) DO UPDATE SET "
            "username = EXCLUDED.username, full_name = EXCLUDED.full_name",
            (user.id, user.username or '', user.full_name or '')
        )
        conn.commit()
        cur.execute("SELECT telegram_id FROM public.users WHERE telegram_id = %s", (user.id,))
        if cur.fetchone():
            logger.info(f"Successfully ensured user {user.id} exists")
            return True
        return False
    except Exception as e:
        logger.error(f"Error ensuring user {user.id} exists: {e}")
        conn.rollback()
        return False

def build_delete_menu_text(menu_items, week_start):
    valid_days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
    day_order = {day: idx for idx, day in enumerate(valid_days)}
    sorted_items = sorted(menu_items, key=lambda x: day_order.get(x['day'], len(valid_days)))
    text = f"üìã ·ã®·àù·åç·â• ·ãù·à≠·ãù·à≠ ·àà·à≥·àù·äï·â± ·àò·åÄ·àò·à™·ã´ {week_start} (·àà·àò·à∞·à®·ãù ·ã®·â∞·ãà·à∞·äê ·äï·å•·àç ·ã≠·àù·à®·å°):\n"
    for idx, item in enumerate(sorted_items, 1):
        text += f"{idx}. {item['day']}: {item['name']} - {item['price']:.2f} ·â•·à≠\n"
    return text

def get_main_keyboard(user_id):
    if user_id in ADMIN_IDS:
        keyboard = [
            ['üîê ·àù·åç·â• ·ãù·à≠·ãù·à≠ ·ä†·ãò·àù·äï', 'üîê ·àù·åç·â• ·ãù·à≠·ãù·à≠ ·à∞·à≠·ãù'],
            ['üîê ·â∞·àò·ãù·åã·â¢·ãé·âΩ·äï ·â∞·àò·àç·ä®·âµ', 'üîê ·ä≠·çç·ã´·ãé·âΩ·äï ·â∞·àò·àç·ä®·âµ'],
            ['üîê ·ä≠·çç·ã´·ãé·âΩ·äï ·ä†·à®·åã·åç·å•', 'üîê ·ã®·ãï·àà·âµ ·âµ·ãï·ãõ·ãû·âΩ'],
            ['üîê ·àõ·àµ·â≥·ãà·âÇ·ã´', 'üîê ·â¶·â≥ ·ä†·ãò·åã·åÖ'],
            ['üîê ·â¶·â≥·ãé·âΩ·äï ·â∞·àò·àç·ä®·âµ']
        ]
    else:
        keyboard = [['üí¨ ·ãµ·åã·çç']]
    return ReplyKeyboardMarkup(keyboard, resize_keyboard=True)

# Start command with updated onboarding message
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    conn = None
    cur = None
    try:
        conn = get_db_connection()
        cur = conn.cursor()
        # Onboarding message in Amharic
        onboarding_text = (
            "üëã ·ä•·äï·ä≥·äï ·ãà·ã∞ ·ä¶·ãù ·ä™·âΩ·äï ·ã®·àù·åç·â• ·àù·ãù·åà·â£ ·â†·ã∞·äì ·àò·å°!\n"
            "·âµ·ä©·àµ ·ä•·äì ·å£·çã·å≠ ·àù·åç·â¶·âΩ·äï ·â†·äê·åª ·àà·ä•·à≠·àµ·ãé ·ä•·äì·ã∞·à≠·à≥·àà·äï·ç¢\n\n"
            "·ã®·ä†·åà·àç·åç·àé·â± ·àò·åç·àà·å´·ãé·âΩ ·ä•·äì ·àÇ·ã∞·â∂·âΩ:\n"
            "1Ô∏è‚É£ ·ã®·àù·ãù·åà·â£ ·ä•·âÖ·ãµ·ãé·äï ·ä•·äì ·âÄ·äï ·ã≠·àù·à®·å°\n"
            "2Ô∏è‚É£ ·ã®·àö·ãà·ã∑·â∏·ãç·äï ·àù·åç·â¶·âΩ ·ä®·àù·åç·â• ·ãù·à≠·ãù·à≠ ·ãç·àµ·å• ·ã≠·àù·à®·å° (·ãà·ã≠·äï·àù ·ä®·çà·àà·åâ ·â†·àº·çç ·ãç·à≥·äî)\n"
            "3Ô∏è‚É£ ·â†·ã®·âÄ·äë ·ã®·àõ·àµ·â≥·ãà·àª ·àò·àç·ä≠·âµ ·ã´·åà·äõ·àâ ·ä•·äì ·ä†·àµ·çà·àã·åä ·àÜ·äñ ·à≤·åà·äù ·ã®·àò·à∞·à®·ãù ·ä•·äì ·ãà·ã∞·àå·àã ·ã®·åä·ãú ·àõ·ãò·ãã·ãà·à≠ ·ã≠·âª·àã·àç·ç¢"
        )
        # Check if user is registered
        cur.execute("SELECT full_name, phone_number FROM public.users WHERE telegram_id = %s", (user.id,))
        user_data = cur.fetchone()
        if user_data and user_data[0] and user_data[1]:
            # Show full main menu
            await update.message.reply_text(
                f"üëã ·ä•·äï·ä≥·äï ·â∞·àò·àç·à∞·ãç ·àò·å° {user.first_name}!\n{onboarding_text}",
                reply_markup=get_main_keyboard(user.id)
            )
            return MAIN_MENU
        else:
            # Show only two buttons for new users
            keyboard = [['üìã ·ã≠·àò·ãù·åà·â°', 'üí¨ ·ãµ·åã·çç']]
            await update.message.reply_text(
                onboarding_text,
                reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
            )
            return MAIN_MENU
    except Exception as e:
        logger.error(f"Error in start for user {user.id}: {e}")
        await update.message.reply_text("‚ùå ·â†·àò·åÄ·àò·à≠ ·àã·ã≠ ·àµ·àÖ·â∞·âµ ·â∞·ä®·àµ·â∑·àç·ç¢ ·ä•·â£·ä≠·ãé ·ä•·äï·ã∞·åà·äì ·ã≠·àû·ä≠·à©·ç¢")
        return MAIN_MENU
    finally:
        if cur:
            cur.close()
        if conn:
            conn.close()

# Support handler
async def support_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "üìû ·ã®·ä†·àµ·â∞·ã≥·ã≥·à™·ãç·äï ·ã´·åç·äô·ç° 0940406707",
        reply_markup=ReplyKeyboardMarkup([['üîô ·â∞·àò·àà·àµ']], resize_keyboard=True)
    )
    return SUPPORT_MENU

# Back to main menu
async def back_to_main(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    conn = get_db_connection()
    cur = conn.cursor()
    cur.execute("SELECT full_name, phone_number FROM public.users WHERE telegram_id = %s", (user.id,))
    user_data = cur.fetchone()
    cur.close()
    conn.close()
    if user_data and user_data[0] and user_data[1]:
        await update.message.reply_text(
            "üßæ ·ãà·ã∞ ·ãã·äì ·åà·åΩ ·â∞·àò·àà·àµ·â∞·ãã·àç·ç¢",
            reply_markup=get_main_keyboard(user.id)
        )
        return MAIN_MENU
    else:
        keyboard = [['üìã ·ã≠·àò·ãù·åà·â°', 'üí¨ ·ãµ·åã·çç']]
        await update.message.reply_text(
            "üßæ ·ãà·ã∞ ·ãã·äì ·åà·åΩ ·â∞·àò·àà·àµ·â∞·ãã·àç·ç¢",
            reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
        )
        return MAIN_MENU

# Help command (used after payment approval and for "·ä•·à≠·ã≥·â≥ ·ä†·åç·äù")
async def send_help_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    commands_text = (
        "üëã ·ä•·äï·ä≥·äï ·ãà·ã∞ ·ä¶·ãù ·ä™·âΩ·äï ·ã®·àù·åç·â• ·àù·ãù·åà·â£ ·â†·ã∞·äì ·àò·å°!\n"
        "·âµ·ä©·àµ ·ä•·äì ·å£·çã·å≠ ·àù·åç·â¶·âΩ·äï ·â†·äê·åª ·àà·ä•·à≠·àµ·ãé ·ä•·äì·ã∞·à≠·à≥·àà·äï·ç¢\n"
        "·ã®·ä†·åà·àç·åç·àé·â± ·àò·åç·àà·å´·ãé·âΩ ·ä•·äì ·àÇ·ã∞·â∂·âΩ?\n"
        "1Ô∏è‚É£ ·ã®·àù·ãù·åà·â£ ·ä•·âÖ·ãµ·ãé·äï ·ä•·äì ·âÄ·äï ·ã≠·àù·à®·å°\n"
        "2Ô∏è‚É£ ·ã®·àö·ãà·ã∑·â∏·ãç·äï ·àù·åç·â¶·âΩ ·ä®·àù·åç·â• ·ãù·à≠·ãù·à≠ ·ãç·àµ·å• ·ã≠·àù·à®·å° (·ãà·ã≠·äï·àù ·ä®·çà·àà·åâ ·â†·àº·çç ·ãç·à≥·äî)\n"
        "3Ô∏è‚É£ ·â†·ã®·âÄ·äë ·ã®·àõ·àµ·â≥·ãà·àª ·àò·àç·ä≠·âµ ·ã´·åà·äõ·àâ ·ä•·äì ·ä†·àµ·çà·àã·åä ·àÜ·äñ ·à≤·åà·äù ·ã®·àò·à∞·à®·ãù ·ä•·äì ·ãà·ã∞·àå·àã ·ã®·åä·ãú ·àõ·ãò·ãã·ãà·à≠ ·ã≠·âª·àã·àç·ç¢"
    )
    if user.id in ADMIN_IDS:
        commands_text += (
            "\nüîê ·ã®·ä†·àµ·â∞·ã≥·ã≥·à™ ·âµ·ãï·ãõ·ãû·âΩ:\n"
            "/admin_update_menu - ·ã®·à≥·àù·äï·â±·äï ·àù·åç·â• ·ãù·à≠·ãù·à≠ ·ã´·ãò·àù·äë\n"
            "/admin_delete_menu - ·ã®·à≥·àù·äï·â±·äï ·àù·åç·â• ·ãù·à≠·ãù·à≠ ·ã≠·à∞·à≠·ãô\n"
            "/admin_subscribers - ·äï·âÅ ·â∞·àò·ãù·åã·â¢·ãé·âΩ·äï ·ã≠·àò·àç·ä®·â±\n"
            "/admin_payments - ·ä≠·çç·ã´·ãé·âΩ·äï ·ã≠·ä®·â≥·â∞·àâ\n"
            "/admin_approve_payment - ·â∞·å†·â£·âÇ ·ä≠·çç·ã´·ãé·âΩ·äï ·ã´·à®·åã·åç·å° ·ãà·ã≠·àù ·ãç·ãµ·âÖ ·ã´·ãµ·à≠·åâ\n"
            "/admin_daily_orders - ·ã®·ãï·àà·âµ ·âµ·ãï·ãõ·ãù ·ãù·à≠·ãù·à≠ ·ã≠·àò·àç·ä®·â±\n"
            "/admin_announce - ·àõ·àµ·â≥·ãà·âÇ·ã´·ãé·âΩ·äï ·ã≠·àã·ä©\n"
            "/setadminlocation - ·ã®·ä´·çå ·â¶·â≥ ·ã´·ãò·åã·åÅ\n"
            "/viewlocations - ·ã®·â∞·åã·à© ·â¶·â≥·ãé·âΩ·äï ·ã≠·àò·àç·ä®·â±"
        )
    await update.message.reply_text(commands_text, reply_markup=get_main_keyboard(user.id))

# Registration: Full name
async def register_name(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if update.message.text == 'üîô ·â∞·àò·àà·àµ':
        return await back_to_main(update, context)
    await update.message.reply_text(
        "·ä•·â£·ä≠·ãé ·àô·àâ ·àµ·àù·ãé·äï ·ã´·àµ·åà·â°·ç¢",
        reply_markup=ReplyKeyboardMarkup([['üîô ·â∞·àò·àà·àµ']], resize_keyboard=True)
    )
    return REGISTER_NAME

async def save_name(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if update.message.text == 'üîô ·â∞·àò·àà·àµ':
        return await back_to_main(update, context)
    context.user_data['full_name'] = update.message.text
    conn = None
    cur = None
    try:
        conn = get_db_connection()
        cur = conn.cursor()
        if not await ensure_user_exists(user, conn, cur):
            await update.message.reply_text("‚ùå ·â∞·å†·âÉ·àö ·àò·àò·ãù·åà·â• ·àã·ã≠ ·àµ·àÖ·â∞·âµ ·â∞·ä®·àµ·â∑·àç·ç¢ ·ä•·â£·ä≠·ãé ·ä•·äï·ã∞·åà·äì ·ã≠·àû·ä≠·à©·ç¢")
            return MAIN_MENU
        cur.execute(
            "UPDATE public.users SET full_name = %s WHERE telegram_id = %s",
            (context.user_data['full_name'], user.id)
        )
        conn.commit()
        await update.message.reply_text(
            "·ä•·â£·ä≠·ãé ·àµ·àç·ä≠ ·âÅ·å•·à≠·ãé·äï ·ã´·àµ·åà·â° (·àà·àù·à≥·àå: 0912345678)·ç¢",
            reply_markup=ReplyKeyboardMarkup([['üîô ·â∞·àò·àà·àµ']], resize_keyboard=True)
        )
        return REGISTER_PHONE
    except Exception as e:
        logger.error(f"Error saving name for user {user.id}: {e}")
        await update.message.reply_text("‚ùå ·àµ·àù ·â†·àõ·àµ·âÄ·àò·å• ·àã·ã≠ ·àµ·àÖ·â∞·âµ ·â∞·ä®·àµ·â∑·àç·ç¢ ·ä•·â£·ä≠·ãé ·ä•·äï·ã∞·åà·äì ·ã≠·àû·ä≠·à©·ç¢")
        return REGISTER_NAME
    finally:
        if cur:
            cur.close()
        if conn:
            conn.close()

# Registration: Phone number (manual input only)
async def register_phone(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if update.message.text == 'üîô ·â∞·àò·àà·àµ':
        return await back_to_main(update, context)
    phone_number = update.message.text.strip()
    # Basic phone validation (Ethiopian format)
    if not re.match(r'^09\d{8}$', phone_number):
        await update.message.reply_text(
            "‚ùå ·ã®·àõ·ã≠·à∞·à´ ·àµ·àç·ä≠ ·âÅ·å•·à≠·ç¢ ·ä•·â£·ä≠·ãé ·âµ·ä≠·ä≠·àà·äõ ·ã®·ä¢·âµ·ãÆ·åµ·ã´ ·âÅ·å•·à≠ ·ã´·àµ·åà·â° (·àà·àù·à≥·àå: 0912345678)·ç¢",
            reply_markup=ReplyKeyboardMarkup([['üîô ·â∞·àò·àà·àµ']], resize_keyboard=True)
        )
        return REGISTER_PHONE
    context.user_data['phone_number'] = phone_number
    conn = None
    cur = None
    try:
        conn = get_db_connection()
        cur = conn.cursor()
        cur.execute(
            "UPDATE public.users SET phone_number = %s WHERE telegram_id = %s",
            (phone_number, user.id)
        )
        conn.commit()
        await update.message.reply_text(
            "·ä•·â£·ä≠·ãé ·ã®·àò·àã·ä™·ã´ ·â¶·â≥·ãé·äï ·ã´·àµ·åà·â° ·ç¢",
            reply_markup=ReplyKeyboardMarkup(
                [[{"text": "üìç ·â¶·â≥ ·ä†·åã·à´", "request_location": True}, {"text": "·ãù·àà·àç"}, 'üîô ·â∞·àò·àà·àµ']],
                resize_keyboard=True,
                one_time_keyboard=True
            )
        )
        return REGISTER_LOCATION
    except Exception as e:
        logger.error(f"Error saving phone for user {user.id}: {e}")
        await update.message.reply_text("‚ùå ·àµ·àç·ä≠ ·âÅ·å•·à≠ ·â†·àõ·àµ·âÄ·àò·å• ·àã·ã≠ ·àµ·àÖ·â∞·âµ ·â∞·ä®·àµ·â∑·àç·ç¢ ·ä•·â£·ä≠·ãé ·ä•·äï·ã∞·åà·äì ·ã≠·àû·ä≠·à©·ç¢")
        return REGISTER_PHONE
    finally:
        if cur:
            cur.close()
        if conn:
            conn.close()

# Registration: Location
async def register_location(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if update.message.text == 'üîô ·â∞·àò·àà·àµ':
        return await back_to_main(update, context)
    location = None
    if update.message.location:
        try:
            latitude = float(update.message.location.latitude)
            longitude = float(update.message.location.longitude)
            location = f"({latitude:.6f}, {longitude:.6f})"
        except (TypeError, ValueError) as e:
            logger.error(f"Error processing location coordinates for user {user.id}: {e}")
            await update.message.reply_text("‚ùå ·ã®·àõ·ã≠·à∞·à´ ·â¶·â≥·ç¢ ·ä•·â£·ä≠·ãé ·â∞·åà·â¢ ·â¶·â≥ ·ã´·åã·à© ·ãà·ã≠·àù '·ãù·àà·àç' ·ã≠·çÉ·çâ·ç¢")
            return REGISTER_LOCATION
    elif update.message.text.lower() != '·ãù·àà·àç':
        location = update.message.text
    context.user_data['location'] = location
    conn = None
    cur = None
    try:
        conn = get_db_connection()
        cur = conn.cursor()
        cur.execute(
            "UPDATE public.users SET location = %s WHERE telegram_id = %s",
            (location, user.id)
        )
        conn.commit()
        # Check if location is coordinates and inside delivery polygon
        if location and location.startswith('(') and ',' in location:
            try:
                match = re.match(r'\(\s*(-?\d+(?:\.\d+)?)\s*,\s*(-?\d+(?:\.\d+)?)\s*\)', location)
                if match:
                    user_lat = float(match.group(1))
                    user_lng = float(match.group(2))
                    user_point = Point(user_lng, user_lat)
                    if not DELIVERY_POLYGON.contains(user_point):
                        await update.message.reply_text(
                            "‚ùå ·â†·ä•·à≠·àµ·ãé ·â¶·â≥ ·ä†·åà·àç·åç·àé·âµ ·ä†·äï·à∞·å•·àù·ç¢ ·ä•·â£·ä≠·ãé ·â†·àõ·àµ·â∞·äì·çà·àª ·ä†·ä´·â£·â¢ ·ãç·àµ·å• ·ã´·àà ·â¶·â≥ ·ã´·åã·à©·ç¢"
                        )
                        return REGISTER_LOCATION
            except Exception as e:
                logger.error(f"Error checking polygon for user {user.id}: {e}")
                await update.message.reply_text("‚ùå ·â¶·â≥ ·â†·àõ·àµ·ä¨·ãµ ·àã·ã≠ ·àµ·àÖ·â∞·âµ·ç¢ ·ä•·â£·ä≠·ãé ·â∞·åà·â¢ ·â¶·â≥ ·ã´·åã·à© ·ãà·ã≠·àù '·ãù·àà·àç' ·ã≠·çÉ·çâ·ç¢")
                return REGISTER_LOCATION
        # Display entered information
        registration_text = (
            "·ã´·àµ·åà·â°·âµ ·àò·à®·åÉ:\n"
            f"·àô·àâ ·àµ·àù: {context.user_data.get('full_name', '·ã®·àà·àù')}\n"
            f"·àµ·àç·ä≠ ·âÅ·å•·à≠: {context.user_data.get('phone_number', '·ã®·àà·àù')}\n"
            f"·ã®·àò·àã·ä™·ã´ ·â¶·â≥: {context.user_data.get('location', '·ã®·àà·àù')}\n"
            "·àò·à®·åÉ·ãç·äï ·ã´·à®·åã·åç·å°·ç¢ ·âµ·ä≠·ä≠·àç ·ä®·àÜ·äê '·àò·à®·åÉ·ãç ·âµ·ä≠·ä≠·àç ·äê·ãç ·âÄ·å•·àç' ·ã≠·àù·à®·å°·ç£ ·ä´·àç·àÜ·äê '·ä†·àµ·â∞·ä´·ä≠·àç' ·ã≠·àù·à®·å°·ç¢"
        )
        keyboard = [['‚úÖ ·àò·à®·åÉ·ãç ·âµ·ä≠·ä≠·àç ·äê·ãç ·âÄ·å•·àç', '‚õî ·ä†·àµ·â∞·ä´·ä≠·àç'], ['üîô ·â∞·àò·àà·àµ']]
        await update.message.reply_text(
            registration_text,
            reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=True)
        )
        return CONFIRM_REGISTRATION
    except Exception as e:
        logger.error(f"Error saving location for user {user.id}: {e}")
        await update.message.reply_text("‚ùå ·â¶·â≥ ·â†·àõ·àµ·âÄ·àò·å• ·àã·ã≠ ·àµ·àÖ·â∞·âµ·ç¢ ·ä•·â£·ä≠·ãé ·ä•·äï·ã∞·åà·äì ·ã≠·àû·ä≠·à© ·ãà·ã≠·àù '·ãù·àà·àç' ·ã≠·çÉ·çâ·ç¢")
        return REGISTER_LOCATION
    finally:
        if cur:
            cur.close()
        if conn:
            conn.close()

# Confirm registration
async def confirm_registration(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    choice = update.message.text
    if choice == 'üîô ·â∞·àò·àà·àµ':
        return await back_to_main(update, context)
    elif choice == '‚õî ·ä†·àµ·â∞·ä´·ä≠·àç':
        context.user_data.clear()
        await update.message.reply_text(
            "·ä•·â£·ä≠·ãé ·àô·àâ ·àµ·àù·ãé·äï ·ã´·àµ·åà·â°·ç¢",
            reply_markup=ReplyKeyboardMarkup([['üîô ·â∞·àò·àà·àµ']], resize_keyboard=True)
        )
        return REGISTER_NAME
    elif choice == '‚úÖ ·àò·à®·åÉ·ãç ·âµ·ä≠·ä≠·àç ·äê·ãç ·âÄ·å•·àç':
        await update.message.reply_text(
            "‚úÖ Registration completed successfully!",
            reply_markup=get_main_keyboard(user.id)
        )
        return MAIN_MENU
    else:
        await update.message.reply_text(
            "‚ùå ·ä•·â£·ä≠·ãé '‚úÖ ·àò·à®·åÉ·ãç ·âµ·ä≠·ä≠·àç ·äê·ãç ·âÄ·å•·àç' ·ãà·ã≠·àù '‚õî ·ä†·àµ·â∞·ä´·ä≠·àç' ·ã≠·àù·à®·å°·ç¢",
            reply_markup=ReplyKeyboardMarkup(
                [['‚úÖ ·àò·à®·åÉ·ãç ·âµ·ä≠·ä≠·àç ·äê·ãç ·âÄ·å•·àç', '‚õî ·ä†·àµ·â∞·ä´·ä≠·àç'], ['üîô ·â∞·àò·àà·àµ']],
                resize_keyboard=True,
                one_time_keyboard=True
            )
        )
        return CONFIRM_REGISTRATION

# Admin: Approve or reject payment
async def admin_approve_payment(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if user.id not in ADMIN_IDS:
        await update.message.reply_text("‚ùå ·ä†·â•·à´·à™ ·ã®·àà·ãé·âµ·àù·ç¢", reply_markup=get_main_keyboard(user.id))
        return MAIN_MENU
    conn = None
    cur = None
    try:
        conn = get_db_connection()
        cur = conn.cursor()
        cur.execute(
            "SELECT p.id, u.full_name, u.username, p.amount, p.receipt_url, p.user_id, p.subscription_id "
            "FROM public.payments p JOIN public.users u ON p.user_id = u.telegram_id "
            "WHERE p.status = 'pending' ORDER BY p.created_at DESC"
        )
        payments = cur.fetchall()
        if not payments:
            await update.message.reply_text(
                "üì≠ ·àà·çç·â∞·àª ·â∞·å†·â£·âÇ ·ä≠·çç·ã´·ãé·âΩ ·ã®·àâ·àù·ç¢",
                reply_markup=get_main_keyboard(user.id)
            )
            return MAIN_MENU
        for payment_id, full_name, username, amount, receipt_url, user_id, subscription_id in payments:
            keyboard = [
                [InlineKeyboardButton("·ä†·à®·åã·åç·å•", callback_data=f"approve_payment_{payment_id}"),
                 InlineKeyboardButton("·ãç·ãµ·âÖ", callback_data=f"reject_payment_{payment_id}")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            try:
                if receipt_url and validators.url(receipt_url):
                    try:
                        await context.bot.send_photo(
                            chat_id=user.id,
                            photo=receipt_url,
                            caption=f"·ä≠·çç·ã´ #{payment_id}\n"
                                    f"·â∞·å†·âÉ·àö: {full_name or '·ã®·àà·àù'} (@{username or '·ã®·àà·àù'})\n"
                                    f"·àò·å†·äï: {amount:.2f} ·â•·à≠",
                            reply_markup=reply_markup
                        )
                    except Exception as e:
                        logger.error(f"Error sending photo for payment {payment_id} to admin {user.id}: {e}")
                        await context.bot.send_message(
                            chat_id=user.id,
                            text=f"·ä≠·çç·ã´ #{payment_id}\n"
                                 f"·â∞·å†·âÉ·àö: {full_name or '·ã®·àà·àù'} (@{username or '·ã®·àà·àù'})\n"
                                 f"·àò·å†·äï: {amount:.2f} ·â•·à≠\n"
                                 f"·ã®·àµ·àù·àç·å£ URL: {receipt_url}\n"
                                 f"(·àõ·à≥·ãà·âÇ·ã´: ·àµ·â∂ ·àõ·à≥·ã®·âµ ·àµ·àÖ·â∞·âµ ·â∞·ä®·à∞·â∞: {str(e)})",
                            reply_markup=reply_markup
                        )
                else:
                    await context.bot.send_message(
                        chat_id=user.id,
                        text=f"·ä≠·çç·ã´ #{payment_id}\n"
                             f"·â∞·å†·âÉ·àö: {full_name or '·ã®·àà·àù'} (@{username or '·ã®·àà·àù'})\n"
                             f"·àò·å†·äï: {amount:.2f} ·â•·à≠\n"
                             f"·ã®·àµ·àù·àç·å£ URL: {receipt_url or '·ã®·àà·àù'} (·ã®·àõ·ã≠·à∞·à´ ·ãà·ã≠·àù ·ã®·àà·àù URL)",
                        reply_markup=reply_markup
                    )
            except Exception as e:
                logger.error(f"Error processing payment {payment_id} for admin {user.id}: {e}")
                await context.bot.send_message(
                    chat_id=user.id,
                    text=f"·ä≠·çç·ã´ #{payment_id}\n"
                         f"·â∞·å†·âÉ·àö: {full_name or '·ã®·àà·àù'} (@{username or '·ã®·àà·àù'})\n"
                         f"·àò·å†·äï: {amount:.2f} ·â•·à≠\n"
                         f"·àµ·àÖ·â∞·âµ: ·ã®·ä≠·çç·ã´ ·ãù·à≠·ãù·à≠ ·àõ·àµ·â∞·ä´·ä®·àç ·ä†·àç·â∞·à≥·ä´·àù",
                    reply_markup=reply_markup
                )
        await update.message.reply_text(
            "üì∑ ·ä®·àã·ã≠ ·â∞·å†·â£·âÇ ·ã®·ä≠·çç·ã´ ·àµ·àù·àç·å£·ãé·âΩ ·äì·â∏·ãç·ç¢ ·äï·å£·çé·âΩ·äï ·â∞·å†·âÄ·àô ·àà·ä†·à®·åã·åç·å• ·ãà·ã≠·àù ·àà·ãç·ãµ·âÖ·ç¢",
            reply_markup=get_main_keyboard(user.id)
        )
        return MAIN_MENU
    except Exception as e:
        logger.error(f"Error fetching pending payments: {e}")
        await update.message.reply_text("‚ùå ·â∞·å†·â£·âÇ ·ä≠·çç·ã´·ãé·âΩ·äï ·àò·å´·äï ·àã·ã≠ ·àµ·àÖ·â∞·âµ·ç¢ ·ä•·â£·ä≠·ãé ·ä•·äï·ã∞·åà·äì ·ã≠·àû·ä≠·à©·ç¢", reply_markup=get_main_keyboard(user.id))
        return MAIN_MENU
    finally:
        if cur:
            cur.close()
        if conn:
            conn.close()

# Handle payment approval/rejection callback
async def handle_payment_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    data = query.data.split('_')
    action = data[0]
    payment_id = data[2]
    conn = None
    cur = None
    try:
        conn = get_db_connection()
        cur = conn.cursor()
        cur.execute(
            "SELECT user_id, subscription_id FROM public.payments WHERE id = %s AND status = 'pending'",
            (payment_id,)
        )
        payment = cur.fetchone()
        if not payment:
            await query.message.reply_text("‚ùå ·ä≠·çç·ã´ ·ä†·àç·â∞·åà·äò·àù ·ãà·ã≠·àù ·âÄ·ã∞·àù ·â•·àé ·â∞·âÄ·äê·â£ ·äê·ãç·ç¢")
            return
        user_id, subscription_id = payment
        if action == 'approve':
            cur.execute(
                "UPDATE public.payments SET status = 'approved' WHERE id = %s",
                (payment_id,)
            )
            cur.execute(
                "UPDATE public.subscriptions SET status = 'active' WHERE id = %s",
                (subscription_id,)
            )
            conn.commit()
            await query.message.reply_text("‚úÖ ·ä≠·çç·ã´ ·â∞·âÄ·â†·àà·ç¢")
            # Send success message and help text
            await context.bot.send_message(
                chat_id=user_id,
                text="‚úÖ ·ã®·ä•·à≠·àµ·ãé ·ä≠·çç·ã´ ·â∞·âÄ·â†·àà! ·àù·åç·â¶·âΩ·ãé ·â∞·ã∞·à®·åâ·ç¢"
            )
            fake_update = Update(0, message=type('obj', (object,), {'effective_user': type('obj', (object,), {'id': user_id})}))
            await send_help_text(fake_update, context)
        elif action == 'reject':
            cur.execute(
                "UPDATE public.payments SET status = 'rejected' WHERE id = %s",
                (payment_id,)
            )
            cur.execute(
                "DELETE FROM public.orders WHERE subscription_id = %s",
                (subscription_id,)
            )
            cur.execute(
                "DELETE FROM public.subscriptions WHERE id = %s",
                (subscription_id,)
            )
            conn.commit()
            await query.message.reply_text("‚ùå ·ä≠·çç·ã´ ·â∞·ãç·ã∞·âÄ·ç¢")
            await context.bot.send_message(
                chat_id=user_id,
                text="‚ùå ·ã®·ä•·à≠·àµ·ãé ·ä≠·çç·ã´ ·â∞·ãç·ã∞·âÄ·ç¢ ·ä•·â£·ä≠·ãé ·ä® /subscribe ·åã·à≠ ·ä•·äï·ã∞·åà·äì ·ã≠·åÄ·àù·à©·ç¢",
                reply_markup=get_main_keyboard(user_id)
            )
    except Exception as e:
        logger.error(f"Error processing payment callback for payment {payment_id}: {e}")
        await query.message.reply_text("‚ùå ·ã®·ä≠·çç·ã´ ·ä•·à≠·àù·åÉ ·â†·àõ·àµ·â∞·ä´·ä®·àç ·àã·ã≠ ·àµ·àÖ·â∞·âµ·ç¢ ·ä•·â£·ä≠·ãé ·ä•·äï·ã∞·åà·äì ·ã≠·àû·ä≠·à©·ç¢")
    finally:
        if cur:
            cur.close()
        if conn:
            conn.close()

# Admin: Update Menu
async def admin_update_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if user.id not in ADMIN_IDS:
        await update.message.reply_text("‚ùå ·ä†·â•·à´·à™ ·ã®·àà·ãé·âµ·àù·ç¢", reply_markup=get_main_keyboard(user.id))
        return MAIN_MENU
    await update.message.reply_text(
        "üìã ·ä†·ã≤·à±·äï ·àù·åç·â• ·ãù·à≠·ãù·à≠ ·ã´·àµ·åà·â°, ·ä†·äï·ãµ ·äï·å•·àç ·â†·ä†·äï·ãµ ·àò·àµ·àò·à≠ ·â†·âÖ·à≠·åΩ: day category name price\n"
        "·àà·àù·à≥·àå:\n"
        "Monday fasting ·àù·àµ·à≠ ·ãà·å• 160\n"
        "Monday non_fasting ·àù·àµ·à≠ ·â†·àµ·åã 260",
        reply_markup=ReplyKeyboardMarkup([['·à∞·à≠·ãù', 'üîô ·â∞·àò·àà·àµ']], resize_keyboard=True)
    )
    return ADMIN_UPDATE_MENU

async def process_admin_update_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if user.id not in ADMIN_IDS:
        await update.message.reply_text("‚ùå ·ä†·â•·à´·à™ ·ã®·àà·ãé·âµ·àù·ç¢", reply_markup=get_main_keyboard(user.id))
        return MAIN_MENU
    if update.message.text.lower() in ['·à∞·à≠·ãù', 'üîô ·â∞·àò·àà·àµ']:
        await update.message.reply_text("‚ùå ·ã®·àù·åç·â• ·ãù·à≠·ãù·à≠ ·àõ·ãò·àò·äï ·â∞·à∞·à≠·ãü·àç·ç¢", reply_markup=get_main_keyboard(user.id))
        return MAIN_MENU
    try:
        lines = update.message.text.strip().split('\n')
        menu_data = []
        for idx, line in enumerate(lines, 1):
            parts = line.strip().split()
            if len(parts) < 4:
                raise ValueError(f"Invalid format on line {idx}: {line}")
            day = parts[0]
            category = parts[1]
            price = float(parts[-1])
            name = ' '.join(parts[2:-1])
            if day not in ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']:
                raise ValueError(f"Invalid day on line {idx}: {day}")
            if category not in ['fasting', 'non_fasting']:
                raise ValueError(f"Invalid category on line {idx}: {category}")
            menu_data.append({
                'id': idx,
                'name': name,
                'price': price,
                'day': day,
                'category': category
            })
        if not menu_data:
            raise ValueError("No valid menu items provided.")
        today = datetime.now(EAT).date()
        week_start = today - timedelta(days=today.weekday())
        conn = get_db_connection()
        cur = conn.cursor()
        cur.execute(
            "INSERT INTO public.weekly_menus (week_start_date, menu_items) "
            "VALUES (%s, %s) ON CONFLICT (week_start_date) DO UPDATE SET menu_items = EXCLUDED.menu_items",
            (week_start, json.dumps(menu_data))
        )
        conn.commit()
        await update.message.reply_text("‚úÖ ·àù·åç·â• ·ãù·à≠·ãù·à≠ ·â†·â∞·à≥·ä´ ·àÅ·äî·â≥ ·â∞·ãò·àò·äê·ç¢", reply_markup=get_main_keyboard(user.id))
        return MAIN_MENU
    except Exception as e:
        logger.error(f"Error updating menu: {e}")
        await update.message.reply_text(f"‚ùå ·ã®·àõ·ã≠·à∞·à´ ·âÖ·à≠·åΩ ·ãà·ã≠·àù ·àù·åç·â• ·ãù·à≠·ãù·à≠ ·àõ·ãò·àò·äï ·àã·ã≠ ·àµ·àÖ·â∞·âµ: {str(e)}·ç¢ ·ä•·â£·ä≠·ãé ·ä•·äï·ã∞·åà·äì ·ã≠·àû·ä≠·à©·ç¢", reply_markup=ReplyKeyboardMarkup([['·à∞·à≠·ãù', 'üîô ·â∞·àò·àà·àµ']], resize_keyboard=True))
        return ADMIN_UPDATE_MENU
    finally:
        if 'cur' in locals():
            cur.close()
        if 'conn' in locals():
            conn.close()

# Admin: Delete Menu
async def admin_delete_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if user.id not in ADMIN_IDS:
        await update.message.reply_text("‚ùå ·ä†·â•·à´·à™ ·ã®·àà·ãé·âµ·àù·ç¢", reply_markup=get_main_keyboard(user.id))
        return MAIN_MENU
    conn = None
    cur = None
    try:
        conn = get_db_connection()
        cur = conn.cursor()
        today = datetime.now(EAT).date()
        week_start = today - timedelta(days=today.weekday())
        cur.execute(
            "SELECT menu_items FROM public.weekly_menus WHERE week_start_date = %s",
            (week_start,)
        )
        menu = cur.fetchone()
        if not menu:
            await update.message.reply_text("‚ùå ·àà·ãö·àÖ ·à≥·àù·äï·âµ ·àù·åç·â• ·ãù·à≠·ãù·à≠ ·ä†·àç·â∞·åà·äò·àù·ç¢", reply_markup=get_main_keyboard(user.id))
            return MAIN_MENU
        menu_items = json.loads(menu[0]) if isinstance(menu[0], str) else menu[0]
        if not menu_items:
            await update.message.reply_text("‚ùå ·àù·åç·â• ·ãù·à≠·ãù·à© ·â£·ã∂ ·äê·ãç·ç¢", reply_markup=get_main_keyboard(user.id))
            return MAIN_MENU
        context.user_data['week_start'] = week_start
        context.user_data['menu_items'] = menu_items
        text = build_delete_menu_text(menu_items, week_start)
        await update.message.reply_text(
            f"{text}\n·àà·àõ·àµ·ãà·åà·ãµ ·ã®·äï·å•·àâ·äï ·ã´·àµ·åà·â° (·àà·àù·à≥·àå '1') ·ãà·ã≠·àù '·à∞·à≠·ãù'·ç¢",
            reply_markup=ReplyKeyboardMarkup([['·à∞·à≠·ãù', 'üîô ·â∞·àò·àà·àµ']], resize_keyboard=True)
        )
        return ADMIN_DELETE_MENU
    except Exception as e:
        logger.error(f"Error fetching menu for deletion: {e}")
        await update.message.reply_text("‚ùå ·àù·åç·â• ·ãù·à≠·ãù·à≠ ·àò·å´·äï ·àã·ã≠ ·àµ·àÖ·â∞·âµ·ç¢ ·ä•·â£·ä≠·ãé ·ä•·äï·ã∞·åà·äì ·ã≠·àû·ä≠·à©·ç¢", reply_markup=get_main_keyboard(user.id))
        return MAIN_MENU
    finally:
        if cur:
            cur.close()
        if conn:
            conn.close()

async def process_admin_delete_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if user.id not in ADMIN_IDS:
        await update.message.reply_text("‚ùå ·ä†·â•·à´·à™ ·ã®·àà·ãé·âµ·àù·ç¢", reply_markup=get_main_keyboard(user.id))
        return MAIN_MENU
    if update.message.text.lower() in ['·à∞·à≠·ãù', 'üîô ·â∞·àò·àà·àµ']:
        await update.message.reply_text("‚ùå ·ã®·àù·åç·â• ·ãù·à≠·ãù·à≠ ·àõ·àµ·ãà·åà·ãµ ·â∞·à∞·à≠·ãü·àç·ç¢", reply_markup=get_main_keyboard(user.id))
        return MAIN_MENU
    try:
        item_idx = int(update.message.text) - 1
        menu_items = context.user_data.get('menu_items', [])
        week_start = context.user_data.get('week_start')
        if not (0 <= item_idx < len(menu_items)):
            await update.message.reply_text(
                f"‚ùå ·ã®·àõ·ã≠·à∞·à´ ·ã®·äï·å•·àç ·âÅ·å•·à≠·ç¢ 1 ·ä•·àµ·ä® {len(menu_items)} ·àò·ä´·ä®·àç ·ã≠·àù·à®·å°·ç¢",
                reply_markup=ReplyKeyboardMarkup([['·à∞·à≠·ãù', 'üîô ·â∞·àò·àà·àµ']], resize_keyboard=True)
            )
            return ADMIN_DELETE_MENU
        menu_items.pop(item_idx)
        conn = get_db_connection()
        cur = conn.cursor()
        cur.execute(
            "UPDATE public.weekly_menus SET menu_items = %s WHERE week_start_date = %s",
            (json.dumps(menu_items), week_start)
        )
        conn.commit()
        await update.message.reply_text("‚úÖ ·ã®·àù·åç·â• ·ãù·à≠·ãù·à≠ ·äï·å•·àç ·â†·â∞·à≥·ä´ ·àÅ·äî·â≥ ·â∞·à∞·à≠·ãü·àç·ç¢", reply_markup=get_main_keyboard(user.id))
        return MAIN_MENU
    except Exception as e:
        logger.error(f"Error deleting menu item: {e}")
        await update.message.reply_text("‚ùå ·ã®·àù·åç·â• ·ãù·à≠·ãù·à≠ ·äï·å•·àç ·â†·àõ·àµ·ãà·åà·ãµ ·àã·ã≠ ·àµ·àÖ·â∞·âµ·ç¢ ·ä•·â£·ä≠·ãé ·ä•·äï·ã∞·åà·äì ·ã≠·àû·ä≠·à©·ç¢", reply_markup=ReplyKeyboardMarkup([['·à∞·à≠·ãù', 'üîô ·â∞·àò·àà·àµ']], resize_keyboard=True))
        return ADMIN_DELETE_MENU
    finally:
        if 'cur' in locals():
            cur.close()
        if 'conn' in locals():
            conn.close()

# Admin: View Subscribers
async def admin_subscribers(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if user.id not in ADMIN_IDS:
        await update.message.reply_text("‚ùå ·ä†·â•·à´·à™ ·ã®·àà·ãé·âµ·àù·ç¢", reply_markup=get_main_keyboard(user.id))
        return MAIN_MENU
    conn = None
    cur = None
    try:
        conn = get_db_connection()
        cur = conn.cursor()
        cur.execute(
            "SELECT u.full_name, u.username, s.plan_type, s.meals_remaining, s.expiry_date "
            "FROM public.subscriptions s JOIN public.users u ON s.user_id = u.telegram_id "
            "WHERE s.status IN ('pending', 'active')"
        )
        subscribers = cur.fetchall()
        if not subscribers:
            await update.message.reply_text("‚ùå ·äï·âÅ ·ãà·ã≠·àù ·â∞·å†·â£·âÇ ·â∞·àò·ãù·åã·â¢·ãé·âΩ ·ä†·àç·â∞·åà·äô·àù·ç¢", reply_markup=get_main_keyboard(user.id))
            return MAIN_MENU
        text = "üìã ·äï·âÅ/·â∞·å†·â£·âÇ ·â∞·àò·ãù·åã·â¢·ãé·âΩ:\n"
        for full_name, username, plan_type, meals_remaining, expiry_date in subscribers:
            text += (
                f"·àµ·àù: {full_name or '·ã®·àà·àù'} (@{username or '·ã®·àà·àù'})\n"
                f"·ä•·âÖ·ãµ: {plan_type.capitalize()}\n"
                f"·âÄ·à™ ·àù·åç·â¶·âΩ: {meals_remaining}\n"
                f"·å´·äì: {expiry_date.strftime('%Y-%m-%d')}\n"
            )
        await update.message.reply_text(text, reply_markup=get_main_keyboard(user.id))
        return MAIN_MENU
    except Exception as e:
        logger.error(f"Error fetching subscribers: {e}")
        await update.message.reply_text("‚ùå ·â∞·àò·ãù·åã·â¢·ãé·âΩ·äï ·àò·å´·äï ·àã·ã≠ ·àµ·àÖ·â∞·âµ·ç¢ ·ä•·â£·ä≠·ãé ·ä•·äï·ã∞·åà·äì ·ã≠·àû·ä≠·à©·ç¢", reply_markup=get_main_keyboard(user.id))
        return MAIN_MENU
    finally:
        if cur:
            cur.close()
        if conn:
            conn.close()

# Admin: Track Payments
async def admin_payments(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if user.id not in ADMIN_IDS:
        await update.message.reply_text("‚ùå ·ä†·â•·à´·à™ ·ã®·àà·ãé·âµ·àù·ç¢", reply_markup=get_main_keyboard(user.id))
        return MAIN_MENU
    conn = None
    cur = None
    try:
        conn = get_db_connection()
        cur = conn.cursor()
        cur.execute(
            "SELECT p.id, u.full_name, u.username, p.amount, p.status, p.created_at "
            "FROM public.payments p JOIN public.users u ON p.user_id = u.telegram_id "
            "ORDER BY p.created_at DESC"
        )
        payments = cur.fetchall()
        if not payments:
            await update.message.reply_text("‚ùå ·ä≠·çç·ã´·ãé·âΩ ·ä†·àç·â∞·åà·äô·àù·ç¢", reply_markup=get_main_keyboard(user.id))
            return MAIN_MENU
        text = "üí∏ ·ã®·ä≠·çç·ã´ ·â≥·à™·ä≠:\n"
        for payment_id, full_name, username, amount, status, created_at in payments:
            text += (
                f"·ä≠·çç·ã´ #{payment_id}\n"
                f"·â∞·å†·âÉ·àö: {full_name or '·ã®·àà·àù'} (@{username or '·ã®·àà·àù'})\n"
                f"·àò·å†·äï: {amount:.2f} ·â•·à≠\n"
                f"·àÅ·äî·â≥: {status.capitalize()}\n"
                f"·âÄ·äï: {created_at.strftime('%Y-%m-%d %H:%M')}\n"
            )
        await update.message.reply_text(text, reply_markup=get_main_keyboard(user.id))
        return MAIN_MENU
    except Exception as e:
        logger.error(f"Error fetching payments: {e}")
        await update.message.reply_text("‚ùå ·ä≠·çç·ã´·ãé·âΩ·äï ·àò·å´·äï ·àã·ã≠ ·àµ·àÖ·â∞·âµ·ç¢ ·ä•·â£·ä≠·ãé ·ä•·äï·ã∞·åà·äì ·ã≠·àû·ä≠·à©·ç¢", reply_markup=get_main_keyboard(user.id))
        return MAIN_MENU
    finally:
        if cur:
            cur.close()
        if conn:
            conn.close()

# Admin: Daily Orders
async def admin_daily_orders(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if user.id not in ADMIN_IDS:
        await update.message.reply_text("‚ùå ·ä†·â•·à´·à™ ·ã®·àà·ãé·âµ·àù·ç¢", reply_markup=get_main_keyboard(user.id))
        return MAIN_MENU
    conn = None
    cur = None
    try:
        conn = get_db_connection()
        cur = conn.cursor()
        today = datetime.now(EAT).date()
        cur.execute(
            "SELECT u.full_name, u.username, o.meal_date, o.items "
            "FROM public.orders o JOIN public.users u ON o.user_id = u.telegram_id "
            "WHERE o.meal_date = %s AND o.status = 'confirmed'",
            (today,)
        )
        orders = cur.fetchall()
        if not orders:
            week_start = today - timedelta(days=today.weekday())
            week_end = week_start + timedelta(days=6)
            cur.execute(
                "SELECT u.full_name, u.username, o.meal_date, o.items "
                "FROM public.orders o JOIN public.users u ON o.user_id = u.telegram_id "
                "WHERE o.meal_date BETWEEN %s AND %s AND o.status = 'confirmed' ORDER BY o.meal_date",
                (week_start, week_end)
            )
            orders = cur.fetchall()
            if not orders:
                await update.message.reply_text(f"‚ùå ·àà{week_start} - {week_end} ·à≥·àù·äï·âµ ·âµ·ãï·ãõ·ãû·âΩ ·ã®·àâ·àù·ç¢", reply_markup=get_main_keyboard(user.id))
                return MAIN_MENU
            text = f"üìÖ ·àà{week_start} - {week_end} ·à≥·àù·äï·âµ ·âµ·ãï·ãõ·ãû·âΩ (·ãõ·à¨ ·ã®·àà·àù):\n"
        else:
            text = f"üìÖ ·àà{today} ·âµ·ãï·ãõ·ãû·âΩ:\n"
        for full_name, username, meal_date, items_json in orders:
            items = json.loads(items_json) if isinstance(items_json, str) else items_json
            text += f"·â∞·å†·âÉ·àö: {full_name or '·ã®·àà·àù'} (@{username or '·ã®·àà·àù'})\n·âÄ·äï: {meal_date}\n"
            for item in items:
                text += f"- {item['name']} ({item['category']})\n"
            text += "\n"
        await update.message.reply_text(text, reply_markup=get_main_keyboard(user.id))
        return MAIN_MENU
    except Exception as e:
        logger.error(f"Error fetching daily orders: {e}")
        await update.message.reply_text("‚ùå ·ã®·ãï·àà·âµ ·âµ·ãï·ãõ·ãû·âΩ·äï ·àò·å´·äï ·àã·ã≠ ·àµ·àÖ·â∞·âµ·ç¢ ·ä•·â£·ä≠·ãé ·ä•·äï·ã∞·åà·äì ·ã≠·àû·ä≠·à©·ç¢", reply_markup=get_main_keyboard(user.id))
        return MAIN_MENU
    finally:
        if cur:
            cur.close()
        if conn:
            conn.close()

# Admin: Announce
async def admin_announce(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if user.id not in ADMIN_IDS:
        await update.message.reply_text("‚ùå ·ä†·â•·à´·à™ ·ã®·àà·ãé·âµ·àù·ç¢", reply_markup=get_main_keyboard(user.id))
        return MAIN_MENU
    await update.message.reply_text(
        "üì¢ ·àà·àÅ·àâ·àù ·â∞·å†·âÉ·àö·ãé·âΩ ·àà·àõ·àµ·â∞·àã·àà·çç ·àò·àç·ä•·ä≠·âµ ·ã´·àµ·åà·â°:",
        reply_markup=ReplyKeyboardMarkup([['·à∞·à≠·ãù', 'üîô ·â∞·àò·àà·àµ']], resize_keyboard=True)
    )
    return ADMIN_ANNOUNCE

async def process_admin_announce(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if user.id not in ADMIN_IDS:
        await update.message.reply_text("‚ùå ·ä†·â•·à´·à™ ·ã®·àà·ãé·âµ·àù·ç¢", reply_markup=get_main_keyboard(user.id))
        return MAIN_MENU
    if update.message.text.lower() in ['·à∞·à≠·ãù', 'üîô ·â∞·àò·àà·àµ']:
        await update.message.reply_text("‚ùå ·àõ·àµ·â≥·ãà·âÇ·ã´ ·â∞·à∞·à≠·ãü·àç·ç¢", reply_markup=get_main_keyboard(user.id))
        return MAIN_MENU
    announcement = update.message.text
    conn = None
    cur = None
    try:
        conn = get_db_connection()
        cur = conn.cursor()
        cur.execute("SELECT telegram_id FROM public.users")
        users = cur.fetchall()
        for user_id, in users:
            try:
                await context.bot.send_message(
                    chat_id=user_id,
                    text=f"üì¢ ·àõ·àµ·â≥·ãà·âÇ·ã´: {announcement}"
                )
            except Exception as e:
                logger.error(f"Error sending announcement to user {user_id}: {e}")
        await update.message.reply_text("‚úÖ ·àõ·àµ·â≥·ãà·âÇ·ã´ ·àà·àÅ·àâ·àù ·â∞·å†·âÉ·àö·ãé·âΩ ·â∞·àã·ä®·ç¢", reply_markup=get_main_keyboard(user.id))
        return MAIN_MENU
    except Exception as e:
        logger.error(f"Error sending announcement: {e}")
        await update.message.reply_text("‚ùå ·àõ·àµ·â≥·ãà·âÇ·ã´ ·â†·àõ·àã·ä≠ ·àã·ã≠ ·àµ·àÖ·â∞·âµ·ç¢ ·ä•·â£·ä≠·ãé ·ä•·äï·ã∞·åà·äì ·ã≠·àû·ä≠·à©·ç¢", reply_markup=ReplyKeyboardMarkup([['·à∞·à≠·ãù', 'üîô ·â∞·àò·àà·àµ']], resize_keyboard=True))
        return ADMIN_ANNOUNCE
    finally:
        if cur:
            cur.close()
        if conn:
            conn.close()

# Admin: Set Location
async def set_admin_location(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if user.id not in ADMIN_IDS:
        await update.message.reply_text("‚ùå ·ä†·â•·à´·à™ ·ã®·àà·ãé·âµ·àù·ç¢", reply_markup=get_main_keyboard(user.id))
        return MAIN_MENU
    await update.message.reply_text(
        "üìç ·ã®·ä´·çå ·â¶·â≥ ·ã´·åã·à© ·ãà·ã≠·àù '·ãù·àà·àç' ·â†·ä•·åÖ ·àà·àò·åª·çç·ç¢",
        reply_markup=ReplyKeyboardMarkup(
            [[{"text": "üìç ·â¶·â≥ ·ä†·åã·à´", "request_location": True}, "·ãù·àà·àç", 'üîô ·â∞·àò·àà·àµ']],
            resize_keyboard=True,
            one_time_keyboard=True
        )
    )
    return SET_ADMIN_LOCATION

async def process_set_admin_location(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if user.id not in ADMIN_IDS:
        await update.message.reply_text("‚ùå ·ä†·â•·à´·à™ ·ã®·àà·ãé·âµ·àù·ç¢", reply_markup=get_main_keyboard(user.id))
        return MAIN_MENU
    if update.message.text in ['üîô ·â∞·àò·àà·àµ', '·ãù·àà·àç']:
        await update.message.reply_text("‚ùå ·â¶·â≥ ·àõ·ãò·åã·åÄ·âµ ·â∞·à∞·à≠·ãü·àç·ç¢", reply_markup=get_main_keyboard(user.id))
        return MAIN_MENU
    location = None
    if update.message.location:
        try:
            latitude = float(update.message.location.latitude)
            longitude = float(update.message.location.longitude)
            location = f"({latitude:.6f}, {longitude:.6f})"
        except Exception as e:
            logger.error(f"Error processing location: {e}")
            await update.message.reply_text("‚ùå ·ã®·àõ·ã≠·à∞·à´ ·â¶·â≥·ç¢ ·ä•·â£·ä≠·ãé ·ä•·äï·ã∞·åà·äì ·ã≠·àû·ä≠·à© ·ãà·ã≠·àù '·ãù·àà·àç' ·ã≠·çÉ·çâ·ç¢", reply_markup=ReplyKeyboardMarkup([["·ãù·àà·àç", 'üîô ·â∞·àò·àà·àµ']], resize_keyboard=True))
            return SET_ADMIN_LOCATION
    else:
        location = update.message.text
    conn = None
    cur = None
    try:
        conn = get_db_connection()
        cur = conn.cursor()
        cur.execute(
            "INSERT INTO public.settings (key, value) VALUES (%s, %s) "
            "ON CONFLICT (key) DO UPDATE SET value = EXCLUDED.value, updated_at = CURRENT_TIMESTAMP",
            (f"admin_location_{user.id}", location)
        )
        conn.commit()
        await update.message.reply_text("‚úÖ ·â¶·â≥ ·â†·â∞·à≥·ä´ ·àÅ·äî·â≥ ·â∞·ãò·åã·åÖ·â∑·àç·ç¢", reply_markup=get_main_keyboard(user.id))
        return MAIN_MENU
    except Exception as e:
        logger.error(f"Error setting admin location: {e}")
        await update.message.reply_text("‚ùå ·â¶·â≥ ·â†·àõ·ãò·åã·åÄ·âµ ·àã·ã≠ ·àµ·àÖ·â∞·âµ·ç¢ ·ä•·â£·ä≠·ãé ·ä•·äï·ã∞·åà·äì ·ã≠·àû·ä≠·à©·ç¢", reply_markup=ReplyKeyboardMarkup([["·ãù·àà·àç", 'üîô ·â∞·àò·àà·àµ']], resize_keyboard=True))
        return SET_ADMIN_LOCATION
    finally:
        if cur:
            cur.close()
        if conn:
            conn.close()

# Admin: View Locations
async def view_locations(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if user.id not in ADMIN_IDS:
        await update.message.reply_text("‚ùå ·ä†·â•·à´·à™ ·ã®·àà·ãé·âµ·àù·ç¢", reply_markup=get_main_keyboard(user.id))
        return MAIN_MENU
    conn = None
    cur = None
    try:
        conn = get_db_connection()
        cur = conn.cursor()
        cur.execute(
            "SELECT key, value FROM public.settings WHERE key LIKE 'admin_location_%'"
        )
        locations = cur.fetchall()
        if not locations:
            await update.message.reply_text("‚ùå ·ã®·â∞·ãò·åã·åÅ ·â¶·â≥·ãé·âΩ ·ã®·àâ·àù·ç¢", reply_markup=get_main_keyboard(user.id))
            return MAIN_MENU
        text = "üìç ·ã®·ä†·àµ·â∞·ã≥·ã≥·à™ ·â¶·â≥·ãé·âΩ:\n"
        for key, value in locations:
            admin_id = key.replace('admin_location_', '')
            text += f"·ä†·àµ·â∞·ã≥·ã≥·à™ {admin_id}: {value}\n"
        await update.message.reply_text(text, reply_markup=get_main_keyboard(user.id))
        return MAIN_MENU
    except Exception as e:
        logger.error(f"Error fetching locations: {e}")
        await update.message.reply_text("‚ùå ·â¶·â≥·ãé·âΩ·äï ·àò·å´·äï ·àã·ã≠ ·àµ·àÖ·â∞·âµ·ç¢ ·ä•·â£·ä≠·ãé ·ä•·äï·ã∞·åà·äì ·ã≠·àû·ä≠·à©·ç¢", reply_markup=get_main_keyboard(user.id))
        return MAIN_MENU
    finally:
        if cur:
            cur.close()
        if conn:
            conn.close()

# Cancel command
async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    context.user_data.clear()
    await update.message.reply_text(
        "‚ùå ·à•·à´ ·â∞·à∞·à≠·ãü·àç·ç¢",
        reply_markup=ReplyKeyboardRemove()
    )
    await update.message.reply_text(
        "üëã ·ä•·äï·ä≥·äï ·â∞·àò·àç·à∞·ãç ·àò·å°! ·ä†·àõ·à´·å≠ ·ã≠·àù·à®·å°:",
        reply_markup=get_main_keyboard(user.id)
    )
    return MAIN_MENU

# Error handler
async def error_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    logger.error(f"Update {update} caused error {context.error}")
    if update and update.message:
        await update.message.reply_text("‚ùå ·àµ·àÖ·â∞·âµ ·â∞·ä®·à∞·â∞·ç¢ ·ä•·â£·ä≠·ãé ·ä•·äï·ã∞·åà·äì ·ã≠·àû·ä≠·à© ·ãà·ã≠·àù ·ãµ·åã·çç ·ã´·äê·åã·åç·à©·ç¢", reply_markup=get_main_keyboard(update.effective_user.id))

# Main function to run the bot
def main():
    try:
        init_db()
        application = Application.builder().token(BOT_TOKEN).build()
        conv_handler = ConversationHandler(
            entry_points=[
                CommandHandler('start', start),
                CommandHandler('admin_update_menu', admin_update_menu),
                CommandHandler('admin_delete_menu', admin_delete_menu),
                CommandHandler('admin_subscribers', admin_subscribers),
                CommandHandler('admin_payments', admin_payments),
                CommandHandler('admin_approve_payment', admin_approve_payment),
                CommandHandler('admin_daily_orders', admin_daily_orders),
                CommandHandler('admin_announce', admin_announce),
                CommandHandler('setadminlocation', set_admin_location),
                CommandHandler('viewlocations', view_locations),
                CommandHandler('cancel', cancel)
            ],
            states={
                MAIN_MENU: [
                    MessageHandler(filters.Regex('^üìã ·ã≠·àò·ãù·åà·â°$'), register_name),
                    MessageHandler(filters.Regex('^üí¨ ·ãµ·åã·çç$'), support_menu),
                    MessageHandler(filters.Regex('^üîê ·àù·åç·â• ·ãù·à≠·ãù·à≠ ·ä†·ãò·àù·äï$'), admin_update_menu),
                    MessageHandler(filters.Regex('^üîê ·àù·åç·â• ·ãù·à≠·ãù·à≠ ·à∞·à≠·ãù$'), admin_delete_menu),
                    MessageHandler(filters.Regex('^üîê ·â∞·àò·ãù·åã·â¢·ãé·âΩ·äï ·â∞·àò·àç·ä®·âµ$'), admin_subscribers),
                    MessageHandler(filters.Regex('^üîê ·ä≠·çç·ã´·ãé·âΩ·äï ·â∞·àò·àç·ä®·âµ$'), admin_payments),
                    MessageHandler(filters.Regex('^üîê ·ä≠·çç·ã´·ãé·âΩ·äï ·ä†·à®·åã·åç·å•$'), admin_approve_payment),
                    MessageHandler(filters.Regex('^üîê ·ã®·ãï·àà·âµ ·âµ·ãï·ãõ·ãû·âΩ$'), admin_daily_orders),
                    MessageHandler(filters.Regex('^üîê ·àõ·àµ·â≥·ãà·âÇ·ã´$'), admin_announce),
                    MessageHandler(filters.Regex('^üîê ·â¶·â≥ ·ä†·ãò·åã·åÖ$'), set_admin_location),
                    MessageHandler(filters.Regex('^üîê ·â¶·â≥·ãé·âΩ·äï ·â∞·àò·àç·ä®·âµ$'), view_locations),
                ],
                REGISTER_NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, save_name)],
                REGISTER_PHONE: [MessageHandler(filters.TEXT & ~filters.COMMAND, register_phone)],
                REGISTER_LOCATION: [
                    MessageHandler(filters.LOCATION | (filters.TEXT & ~filters.COMMAND), register_location)
                ],
                CONFIRM_REGISTRATION: [
                    MessageHandler(filters.TEXT & ~filters.COMMAND, confirm_registration)
                ],
                ADMIN_UPDATE_MENU: [
                    MessageHandler(filters.TEXT & ~filters.COMMAND, process_admin_update_menu)
                ],
                ADMIN_DELETE_MENU: [
                    MessageHandler(filters.TEXT & ~filters.COMMAND, process_admin_delete_menu)
                ],
                ADMIN_ANNOUNCE: [
                    MessageHandler(filters.TEXT & ~filters.COMMAND, process_admin_announce)
                ],
                SET_ADMIN_LOCATION: [
                    MessageHandler(filters.LOCATION | (filters.TEXT & ~filters.COMMAND), process_set_admin_location)
                ],
                SUPPORT_MENU: [
                    MessageHandler(filters.Regex('^üîô ·â∞·àò·àà·àµ$'), back_to_main)
                ],
            },
            fallbacks=[CommandHandler('cancel', cancel)],
            allow_reentry=True
        )
        application.add_handler(conv_handler)
        application.add_handler(CallbackQueryHandler(handle_payment_callback))
        application.add_error_handler(error_handler)
        while True:
            try:
                application.run_polling(drop_pending_updates=True, bootstrap_retries=-1, timeout=10, poll_interval=1, allowed_updates=Update.ALL_TYPES)
            except Exception as e:
                logger.error(f"Polling crashed: {e}. Restarting in 10 seconds...")
                sleep(10)
    except Exception as e:
        logger.error(f"Error starting bot: {e}")

if __name__ == '__main__':
    main()